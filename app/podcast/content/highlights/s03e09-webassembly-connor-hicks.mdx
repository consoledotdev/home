**Connor Hicks:** That is exactly how it started, however, it has morphed and
evolved quite a bit from there. WebAssembly, at its simplest, is a binary
representation of a program, same as a lot of other formats. If you compile a
program for x86 or for ARM, it produces a binary. WebAssembly is a binary, not
too dissimilar from those, however, it is designed to be platform agnostic,
infrastructure agnostic, processor agnostic, et cetera, et cetera. It's meant to
run anywhere. The original use case for it was absolutely running compiled
languages in the web browser. C++ was right there at the beginning. But since
then, it has evolved to include non-browser environments like the server, IoT,
all that kind of stuff, and is evolved to support all sorts of different
languages beyond just C++.

**Connor Hicks:** Rust is the winning language, I suppose, you could say here in
terms of first-party compatibility. Rust has had WebAssembly built in directly
for years at this point. Other languages are starting to catch up now, but where
the language doesn't fully support WebAssembly, there are often third-party or
open source projects that fill in the gap. For example, Go has actually been
able to compile with WebAssembly for a long time, but they're a little bit
behind the standard in terms of the support that's built into mainline Go.
